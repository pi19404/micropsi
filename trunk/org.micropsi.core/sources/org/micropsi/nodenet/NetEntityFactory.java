/**
 * $Header: G:\DEV\Workspace\migration3.0\micropsi-cvs-repository\micropsi/org.micropsi.core/sources/org/micropsi/nodenet/NetEntityFactory.java,v 1.8 2006/08/03 15:40:37 rvuine Exp $
 */
package org.micropsi.nodenet;

import java.util.GregorianCalendar;

/**
 * Creates all types of NetEntities.
 */
public class NetEntityFactory {

	private static int entityCreationCounter = -1;
	private static GregorianCalendar time = new GregorianCalendar();
	private static String timestamp;
		
	private synchronized static String getNewID() {
		time.setTimeInMillis(System.currentTimeMillis());
		timestamp 
			= Integer.toString(time.get(GregorianCalendar.YEAR)).substring(2)
			+ Integer.toString(time.get(GregorianCalendar.MONTH)+101).substring(1)
			+ Integer.toString(time.get(GregorianCalendar.DAY_OF_MONTH)+100).substring(1)
			+ "/"
			+ Integer.toString(time.get(GregorianCalendar.HOUR_OF_DAY)+100).substring(1)
			+ Integer.toString(time.get(GregorianCalendar.MINUTE)+100).substring(1)
			+ Integer.toString(time.get(GregorianCalendar.SECOND)+100).substring(1);
		
		entityCreationCounter++;
		return entityCreationCounter+"-"+timestamp;
	}

	private static final NetEntityFactory instance = new NetEntityFactory();
	
	/**
	 * Returns an instance of the factory.
	 * @return NetEntityFactory the instance
	 */
	protected static NetEntityFactory getInstance() {
		return instance;
	}
	
	/**
	 * Creates a new NativeModule. <b> This method constructs an Entity with the
	 * given ID. It should only be called when there is an autogenerated ID
	 * available, e.g. when reconstructing the net from a file</b>. Use the
	 * other createNativeModule method if you want to create a new NativeModule
	 * without having an ID handy.
	 * @param id the id of the new native module
	 * @param implementationName the class name of the implementation (for information purposes only)
	 * @param impl the AbstractNativeModuleImpl to be used in the module
	 * @param parent the module's parent (can be null if the module is to be the
	 * root module)
	 * @param defiant whether the module is to be defiant
	 * @param moduleManager the moduleManager to be used
	 * @param entityManager the entityManager to be used
	 * @param interactionManager the user interaction manager to be used
	 * @return NativeModule the newly created NativeModule, not yet initialized
	 * @throws NetIntegrityException if the ID or the parent ID is bad. 
	 */
	protected synchronized NativeModule createNativeModule(String id, String implementationName, AbstractNativeModuleImpl impl, String parent, boolean defiant, ModuleManager moduleManager, NetEntityManager entityManager, UserInteractionManager interactionManager, NetPropertiesIF netProperties) throws NetIntegrityException {
		
		NativeModule module = new NativeModule(id,parent,implementationName, entityManager,interactionManager,moduleManager,netProperties,defiant);
		module.replaceImplementation(impl);
		
		entityManager.addEntity(module);
		moduleManager.addModule(module);
		Module parmod = module.getParent();
		if(parmod != null && parmod.getEntityType() == NetEntityTypesIF.ET_MODULE_NODESPACE) {
			((NodeSpaceModule)parmod).attachEntity(id,true);
		}
		
		return module;
	}
	
	/**
	 * Creates a new NativeModule, using a new instance of the given class.<b>
	 * This method constructs an Entity with the given ID. It should only be
	 * called when there is an autogenerated ID available, e. g. when
	 * reconstructing the net from a file</b>. Use the other createNativeModule
	 * method if you want to create a new NativeModule without having an ID
	 * handy.
	 * @param id the ID of the new native module.
	 * @param classname the full qualifying class name of the
	 * AbstractNativeModuleImpl  to be used
	 * @param classloader The classloader to be used
	 * @param parent the parent of the new module
	 * @param defiant whether the module is to be defiant
	 * @param manager the module manager to be used
	 * @param entityManager the entity manager to be used
	 * @param interactionManager the user interaction manager
	 * @param netProperties the net properties to be used
	 * @return NativeModule the newly created NativeModule, uninitialized
	 * @throws NetIntegrityException if the ID or the parent is bad
	 */
 	protected synchronized NativeModule createNativeModuleAndInstance(String id, String classname, ClassLoader classloader, String parent, boolean defiant, ModuleManager manager, NetEntityManager entityManager, UserInteractionManager interactionManager, NetPropertiesIF netProperties) throws NetIntegrityException {
		
		AbstractNativeModuleImpl impl = null;
		
		try {
			Class c = classloader.loadClass(classname);	
			impl = (AbstractNativeModuleImpl)c.newInstance();					
		} catch (Throwable e) {
			entityManager.getLogger().warn("Creation of module instance "+classname+" failed. Classloader was: "+classloader,e);
		}
				
		return createNativeModule(id, classname, impl, parent, defiant, manager, entityManager, interactionManager, netProperties);
	}
	
	/**
	 * Creates a new NativeModule with a new, autogenerated ID and a new
	 * instance of the given class. 
	 * @param classname the full qualifying class name of the
	 * AbstractNativeModuleImpl to be used
	 * @param classloader the ClassLoader to be used
	 * @param parent the parent of the new module
	 * @param defiant whether the module is to be defiant
	 * @param manager the module manager to be used
	 * @param entityManager the entity manager to be used
	 * @param interactionManager the user interaction manager to be used
	 * @@param netProperties the net properties to be used
	 * @return NativeModule the newly created NativeModule, uninitialized
	 * @throws NetIntegrityException if the parent is bad
	 */
	
	protected synchronized NativeModule createNativeModuleAndInstance(String classname, ClassLoader classloader, String parent, boolean defiant, ModuleManager manager, NetEntityManager entityManager, UserInteractionManager interactionManager, NetPropertiesIF netProperties) throws NetIntegrityException {
				
		String id = getNewID();
		if(classname != null) {

			AbstractNativeModuleImpl impl = null;

			try {
				Class c = classloader.loadClass(classname);	
				impl = (AbstractNativeModuleImpl)c.newInstance();					
			} catch (Throwable e) {
				entityManager.getLogger().warn("Creation of module instance "+classname+" failed. Classloader was: "+classloader,e);
			}
			return createNativeModule(id, classname, impl, parent, defiant, manager, entityManager, interactionManager, netProperties);
		} else {
			return createNativeModule(id, classname, null, parent, defiant, manager, entityManager, interactionManager, netProperties);
		}
	}
	
	/**
	 * Creates a new nodespace with the given ID. <b> This method constructs an
	 * entity with the given ID. It should only be called when there is an
	 * autogenerated ID available, e. g. when reconstructing the net from a
	 * file</b>. Use the other createNodeSpace method if you want to create a
	 * new NodeSpace without having an ID handy.
	 * @param id the ID of the new NodeSpace
	 * @param parent the parent of the new NodeSpace (can be null if the
	 * NodeSpace is to become the root space)
	 * @param manager the module Manager
	 * @param entityManager the entity manager
	 * @param sensActRegistry the SensActRegistry to be used
	 * @return NodeSpaceModule the new NodeSpace
	 * @throws NetIntegrityException if the id or the parent is bad.
	 */
	protected synchronized NodeSpaceModule createNodeSpace(String id, String parent, ModuleManager manager, NetEntityManager entityManager, SensActRegistry sensActRegistry) throws NetIntegrityException {
		NodeSpaceModule space = new NodeSpaceModule(id,parent,manager,entityManager,sensActRegistry);
		entityManager.addEntity(space);
		manager.addModule(space);
		Module parmod = space.getParent();
		if(parmod != null && parmod instanceof NodeSpaceModule) {
			((NodeSpaceModule)parmod).attachEntity(id,true);
		}
		return space;
	}
	
	/**
	 * Creates a new NodeSpace with a new, auto-generated ID.
	 * @param parent the parent of the new NodeSpace (can be null if the
	 * NodeSpace is to become the root space)
	 * @param manager the module Manager
	 * @param entityManager the entity manager
	 * @param sensActRegistry the SensActRegistry to be used
	 * @return NodeSpaceModule the new NodeSpace
	 * @throws NetIntegrityException if the id or the parent is bad.
	 */
	protected synchronized NodeSpaceModule createNodeSpace(String parent, ModuleManager manager, NetEntityManager entityManager, SensActRegistry sensActRegistry) throws NetIntegrityException {
		String id = getNewID();
		return createNodeSpace(id, parent, manager, entityManager, sensActRegistry);
	} 
	
	/**
	 * Creates a new Node of the given type with the given ID. <b> This method
	 * constructs an entity with the given ID. It should only be called when
	 * there is an autogenerated ID available, e. g. when reconstructing the net
	 * from a file</b>. Use the other createNode method if you want to create a
	 * new Node without having an ID handy.
	 * @param nodeType the type of the new node
	 * @param id the id of the new node
	 * @param name the name of the new node - can be null!
	 * @param manager the entityManager to be used
	 * @param reg the SensActRegistry to be used (can be null if the type is not
	 * NT_SENSOR or NT_ACTOR)
	 * @return Node the newly created node, not yet assigned to any NodeSpace
	 * @throws NetIntegrityException if the ID is bad.
	 * @see NodeFunctionalTypesIF
	 */
	protected synchronized Node createNode(int nodeType, String id, String name, NetEntityManager manager, SensActRegistry reg) throws NetIntegrityException {
		Node toReturn; 
		
		switch(nodeType) {
			case NodeFunctionalTypesIF.NT_CONCEPT:
				toReturn = new ConceptNode(id,manager, DecayIF.NO_DECAY);
				break;
			case NodeFunctionalTypesIF.NT_TOPO:
				toReturn = new TopoNode(id,manager, DecayIF.NO_DECAY);
				break;				
			case NodeFunctionalTypesIF.NT_CHUNK:
				toReturn = new ChunkNode(id,manager, DecayIF.NO_DECAY);
				break;
			case NodeFunctionalTypesIF.NT_ACT_POR:
				toReturn = new ActLinkTypeNode(NodeFunctionalTypesIF.NT_ACT_POR,GateTypesIF.GT_POR,id,manager);
				break;
			case NodeFunctionalTypesIF.NT_ACT_RET:
				toReturn = new ActLinkTypeNode(NodeFunctionalTypesIF.NT_ACT_RET,GateTypesIF.GT_RET,id,manager);
				break;
			case NodeFunctionalTypesIF.NT_ACT_SUB:
				toReturn = new ActLinkTypeNode(NodeFunctionalTypesIF.NT_ACT_SUB,GateTypesIF.GT_SUB,id,manager);
				break;
			case NodeFunctionalTypesIF.NT_ACT_SUR:
				toReturn = new ActLinkTypeNode(NodeFunctionalTypesIF.NT_ACT_SUR,GateTypesIF.GT_SUR,id,manager);
				break;
			case NodeFunctionalTypesIF.NT_ACT_CAT:
				toReturn = new ActLinkTypeNode(NodeFunctionalTypesIF.NT_ACT_CAT,GateTypesIF.GT_CAT,id,manager);
				break;
			case NodeFunctionalTypesIF.NT_ACT_EXP:
				toReturn = new ActLinkTypeNode(NodeFunctionalTypesIF.NT_ACT_EXP,GateTypesIF.GT_EXP,id,manager);
				break;
			case NodeFunctionalTypesIF.NT_ACT_SYM:
				toReturn = new ActLinkTypeNode(NodeFunctionalTypesIF.NT_ACT_SYM,GateTypesIF.GT_SYM,id,manager);
				break;
			case NodeFunctionalTypesIF.NT_ACT_REF:
				toReturn = new ActLinkTypeNode(NodeFunctionalTypesIF.NT_ACT_REF,GateTypesIF.GT_REF,id,manager);
				break;
			case NodeFunctionalTypesIF.NT_ASSOCIATOR:
				toReturn = new AssociatorNode(id,manager);
				break;
			case NodeFunctionalTypesIF.NT_DISSOCIATOR:
				toReturn = new DissociatorNode(id,manager);
				break;
			case NodeFunctionalTypesIF.NT_ACTIVATOR:
				toReturn = new ActivatorNode(id,manager);
				break;
			case NodeFunctionalTypesIF.NT_DEACTIVATOR:
				toReturn = new DeactivatorNode(id,manager);
				break;
			case NodeFunctionalTypesIF.NT_REGISTER:
				toReturn = new RegisterNode(id,manager);
				break;
			case NodeFunctionalTypesIF.NT_SENSOR:
				toReturn = new SensorNode(id,manager,reg);
				break;
			case NodeFunctionalTypesIF.NT_ACTOR:
				toReturn = new ActorNode(id,manager,reg);
				break;
			default: throw new RuntimeException("Fix this, bad node type: "+nodeType);								
		}
	
		manager.addEntity(toReturn);	

		return toReturn;
	} 

	/**
	 * Creates a new node of the given type with a new, auto-generated ID.
	 * @param nodeType the type of the new node
	 * @param space the NodeSpace to attach the new node to. Can be null - if
	 * so, the new node won't be attached to any NodeSpace
	 * @param manager the entityManager to be used
	 * @param reg the SensActRegistry to be used (can be null if the type is not
	 * NT_SENSOR or NT_ACTOR)
	 * @return Node the newly created node, not yet assigned to any NodeSpace
	 * @throws NetIntegrityException if the ID is bad.
	 * @see NodeFunctionalTypesIF
	 */
	protected synchronized Node createNode(int nodeType, NodeSpaceModule space, NetEntityManager manager, SensActRegistry reg) throws NetIntegrityException {
		String id = getNewID();
		Node node = this.createNode(nodeType, id, null, manager, reg);		
		if(space != null) space.attachEntity(id,true);
		return node;
	}
}
